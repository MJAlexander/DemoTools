% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/check_heaping.R
\name{check_heaping_coale_li}
\alias{check_heaping_coale_li}
\title{Coale-Li age heaping index}
\usage{
check_heaping_coale_li(
  Value,
  Age,
  ageMin = 60,
  ageMax = max(Age),
  terms = 5,
  digit = 0
)
}
\arguments{
\item{Value}{numeric. A vector of demographic counts by single age.}

\item{Age}{numeric. A vector of ages corresponding to the lower integer bound of the counts.}

\item{ageMin}{integer. The lowest age included in calculations. Default 25.}

\item{ageMax}{integer. The upper age bound used for calculations. Default 65.}

\item{terms}{integer. Length of the (centered) moving average be. Default 5.}

\item{digit}{integer. Any digit 0-9. Default 0.}
}
\value{
The value of the index.
}
\description{
This implementation is based largely on the sparse verbal description given in
Coale and Li (1991): calculate a two-stage 5-term moving average as a reference pattern, then
take ratios with respect to this. Ratios for a given terminal digit can then be averaged to produce
an index. This procedure was used in that paper for ages 65-100 for mortality rates.
It is probably better suited to rates than counts, but that is not a hard rule.
}
\details{
\code{digit} could also be a vector of digits, but the more digits one includes (excepting 0 and 5) the closer the index will get to 1.
It is therefore recommended for single digits, or else \code{c(0,5)}.
\code{ageMax} is an inclusive upper bound, treated as interval.
If you want ages 20 to 89, then give \code{ageMin = 20} and \code{ageMax = 89}, not 90. By default all available ages greater than or equal to \code{ageMin} are used.
}
\examples{
Age <- 0:99
check_heaping_coale_li(pop1m_pasex, Age, 65, 95, 5, 0) # 3.7
check_heaping_coale_li(pop1m_pasex, Age, 65, 95, 5, 5) # 3.5 almost just as high
}
\references{
\insertRef{coale1991effect}{DemoTools}
}
